= Automatic Redis Failover for Beetle

== How it works

===Our current setup:

* Redis Server: redis-1 / redis-2, of them is our master (redis-1), the other a slave (redis-2)
* Rest of the beetle setup: messaging servers etc.

===How our failover works now:

* on the first need to reach our redis server we go through our configured redis instances and find our current redis master
* subscribers access this server as long as it is available
* when it is not reachable anymore or connection attempts end up in an exception we go into a retry loop
* if the loop finds an active master this becomes our current redis master again
* if the loop finds several active master it throws an exception and stops - this is to make sure we don't get inconsistent datasets

===Our problem(s):

* while this mechanism works for any master slave setup, the slave master nominations and
  changes do not happen automatically. Although this allows an admin to make sure
  everything is in order when he triggers a switch (+1 point) this has the unfortunate
  downside that the system will practically shutdown on redis failures until a manual
  switch has occured (-10000 points).

* in case of network partitioning we rely on the admin to correctly handle the situations.

===Our goals:

* no single point of failure
* automatic switch in case of redis-master failure
* switch should not cause inconsistent data on the redis servers
* subscribers should be able to determine the current redis-master without asking another
  process (as long as the redis servers are working)

===Our solution:

==== single redis server (simple)

* when just one redis server is configured, none of this is done, all systems just use the configured server

==== redis master-slave setup (not so simple)

===== prerequisites

* one redis-configuration-server process ("rc-server", on one server), one redis-configuration-client process ("rc-client") on every worker server
* the rc-server knows about all possible rc-clients using a configured list
* the rc-server and rc-clients exchange messages via a "system queue"
* on startup, an rc-client can determine the current redis-master without the help of the rc-server by checking that either only one redis is available (as master) or by checking that redis master and slave are available
* if an rc-client cannot determine the redis-master, it will retry a couple of times before it finally exits
* when the rc-server finds the redis-master to be down, it will retry a couple of times before starting a reconfiguration round

===== when the redis-master doesn't recover (reconfiguration round)

* the rc-server tells all rc-clients to stop using the redis-master by sending an "invalidate" message
* the rc-clients acknowledge via an "invalidated" message
* the rc-server waits for *all* rc-clients to acknowledge the invalidation
* the rc-server promotes the former redis-slave to become the new redis-master (by sending SLAVEOF no one)
* the rc-server sends a "reconfigure" message containing the new redis-master to every rc-client
* the rc-clients use the new redis-master
