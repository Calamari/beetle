= Beetle Redis Failover

Automatic Redis Failover (+ consistency on network partitions)

== How it works

===Our current setup:

* Redis Server: redis-1 / redis-2, of them is our master (redis-1), the other a slave (redis-2)
* Rest of the beetle setup: messaging servers etc.

===How our failover works now:

* on the first need to reach our redis server we go through our configured redis instances and find our current redis master
* workers and publishers try to access this server as long as it is available
* when it is not reachable anymore or connection attempts end up in an exception we go into a retry loop
* if the loop finds an active master this becomes our current redis master again
* if the loop finds several active master it throws an exception and stops - this is to make sure we don't get inconsistent datasets

===Our problem(s):

* while this mechanism works for any master slave setup, the slave master nominations and changes do not happen automatically. Although this allows an admin to make sure everything is in order when he triggers a switch (+1 point) this has the unfortunate downside that the system will practically shutdown on redis failures until a manual switch has occured (-10000 points).
* (network partition tolerance relies on the admin correctly handling partitioning situations.)

===Our solution:

* one redis-configuration-server process (on some server), redis-configuration-client in every worker process
* on startup, every redis-configuration-client asks the redis-configuration-server for the current redis-master. this is also the registration process for the redis-configuration-clients (they are added to the redis-configuration-clients list of the redis-configuration-server)
* if a redis-configuration-client cannot connect to the redis-configuration-server or does not receive the redis-master info, it will retry a couple of time before it finally exits with an error message
* when the redis-configuration-server finds the redis-master to be down, it will retry a couple of times
* when the redis-master doesn't recover, the redis-configuration-server will ask all known redis-configuration-clients to use the former redis-slave as the new redis-master ("reconfigure message")
* from this moment on no changes are made to the redis-configuration-clients list of the redis-configuration-server, and the redis-configuration-client tells its worker object to stop working by unsubscribing from every work queue (not from the redis-configuration-server queue)
* every redis-configuration-client reconfigures itself to use the new redis-master and acknowledges the reconfiguration ("reconfigured message")
* when *all* redis-configuration-clients have sent the message to acknowledge the reconfiguration, the redis-configuration-server promotes the former redis-slave to become the new redis-master (by sending SLAVEOF no one) and sends a message to every redis-configuration-client to let them continue their work
* every redis-configuration-client tells its worker object to start working again by re-subscribing to its work queues
* starting new workers is now possible again
* TBD: how/when to remove/unregister dead redis-configuration-clients from the redis-configuration-server's workers list?
* TBD: the redis-configuration-clients, instead of asking the redis-configuration-server for the redis-master on start, could also go through the list of redis servers to determine the current redis-master themselves